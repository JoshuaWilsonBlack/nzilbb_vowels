#' Create plot of variances explained from pca_test object
#'
#' The variance explained by each PC in a dataset is plotted with confidence
#' intervals generated by bootstrapping and a null distribution generated by
#' permutation. The function accepts the result of calling the `pca_test`
#' function.
#'
#' By default the variance explained is represented as a percentage. If the
#' option percent is set to FALSE, then the variance explained is represented
#' by the eigenvalues corresponding to each PC.
#'
#' @param pca_test an object of class pca_test_results generated by `pca_test`.
#' @param pc_max the maximum number of PCs to plot. If NA, plot all PCs.
#' @param percent if TRUE, represent variance explained as a percentage. If
#'   FALSE, represent as eigenvalues.
#' @return `ggplot` object.
#' @importFrom dplyr if_else lead rename mutate arrange filter
#' @importFrom stringr str_sub str_detect
#' @importFrom tidyr pivot_longer
#' @importFrom forcats fct_reorder
#' @importFrom ggplot2 ggplot geom_errorbar geom_point scale_x_discrete aes
#'   guide_axis labs
#' @importFrom magrittr %>%
#' @importFrom tidyselect all_of
#' @examples
#' \dontrun{plot_variance_explained(pca_object)}
#' \dontrun{plot_variance_explained(pca_object, pc_max=5, percent=FALSE)}
#' @export
plot_variance_explained <- function(pca_test, pc_max = NA, percent = TRUE) {

  stopifnot(
    "Data must come from an object of class pca_test_results" =
      class(pca_test) == "pca_test_results",
    "pc_max must be a number or NA." =
      is.numeric(pc_max) | is.na(pc_max)
  )

  if (percent) {

    desired_variables <- c(
      'low_confint_var',
      'high_confint_var',
      'low_null_var',
      'high_null_var',
      'variance_explained',
      'PC',
      'sig_PC'
    )

    base_mapping <- aes(
      x = PC,
      y = variance_explained * 100,
      colour = distribution
    )

    error_mapping <- aes(
      ymin = low_limit * 100,
      ymax = high_limit * 100
    )

    var_formant <- '%'

  } else {

    desired_variables <- c(
      'low_confint',
      'high_confint',
      'low_null',
      'high_null',
      'eigenvalue',
      'PC',
      'sig_PC'
    )

    base_mapping <- aes(
      x = PC,
      y = eigenvalue,
      colour = distribution
    )

    error_mapping <- aes(
      ymin = low_limit,
      ymax = high_limit
    )

    var_formant <- 'Eigenvalue'

  }

  # filter high PCs
  if (is.numeric(pc_max)) {
    plot_data <- pca_test$variance %>%
      filter(
        as.numeric(str_sub(PC, start = 3L)) < pc_max
      )
  } else {
    plot_data <- pca_test$variance
  }

  # Output plot
  plot_data %>%
    select(all_of(desired_variables)) %>%
    pivot_longer(
      cols = contains('low'),
      names_to = "distribution",
      values_to = 'low_limit',
      names_pattern = "_(.*)"
    ) %>%
    pivot_longer(
      cols = contains('high'),
      names_to = "distribution_2",
      values_to = 'high_limit',
      names_pattern = "_(.*)"
    ) %>%
    filter(
      distribution == distribution_2
    ) %>%
    select(-distribution_2) %>%
    mutate(
      distribution = if_else(
        str_detect(distribution, 'null'),
        "Null",
        "Confidence"
      )
    ) %>%
    ggplot(
      mapping = base_mapping
    ) +
    geom_errorbar(
      mapping = error_mapping,
      width = 0.2
    ) +
    geom_point(colour = "red") +
    scale_x_discrete(guide = guide_axis(angle = 90)) +
    labs(
      title = "Variance Explained by Principal Components",
      colour = "Test Distribution",
      x = "Principal Component",
      y = glue("Variance Explained ({var_formant})"),
      caption = glue(
        "Bars indicate {pca_test$variance_confint * 100}% confidence intervals."
      )
    )

}

#' Create plot of index loadings for a given PC from pca_test object.
#'
#' Index loadings are presented with confidence intervals generated by
#' bootstrapping and a null distribution generated by permutation.
#'
#' If PCs are unstable, there is an option to take only the bootstrap iterations
#' in which the variable with the highest median loading across all iterations
#' is in the top 3/4 of its distribution. This helps to reveal
#' reliable connections of this variable with other variables in the data set.
#'
#' @param pca_test an object of class pca_test_results generated by `pca_test`.
#' @param pc_no An integer indicating which PC to plot.
#' @param violin If TRUE, violin plots are added for the confidence intervals.
#' @param filter_boots if TRUE, only bootstrap iterations in which the variable
#' with the highest median loading is in the top 3/4 of its range are plotted.
#' @return `ggplot` object.
#' @importFrom dplyr if_else lead rename mutate arrange filter
#' @importFrom stringr str_sub str_detect
#' @importFrom tidyr pivot_longer
#' @importFrom forcats fct_reorder
#' @importFrom ggplot2 ggplot geom_errorbar geom_point scale_x_discrete aes
#'   guide_axis labs
#' @importFrom magrittr %>%
#' @importFrom tidyselect all_of
#' @examples
#' \dontrun{plot_loadings(pca_object, pc_no=1, cutoff=50)}
#' \dontrun{plot_loadings(pca_object, pc_no=2, cutoff=70)}
#' @export
plot_loadings <- function(
    pca_test, pc_no = 1, violin=FALSE, filter_boots = FALSE
) {

  stopifnot(
    "Data must come from an object of class pca_test_results" =
      class(pca_test) == "pca_test_results",
    "pc_no must be a number." =
      is.numeric(pc_no),
    "violin must be either TRUE or FALSE." =
      is.logical(violin),
    "filter_boots must be either TRUE or FALSE." =
      is.logical(filter_boots)
  )

  if (filter_boots) {

    plot_data <- pca_test$raw_data %>%
      filter(
        as.numeric(str_sub(PC, start = 3L)) == pc_no,
        source != "original"
      ) %>%
      group_by(source, variable) %>%
      mutate(
        median_index = median(index_loading),
        first_quartile = quantile(index_loading, 0.25)
      ) %>%
      ungroup() %>%
      mutate(
        largest_loading = median_index == max(median_index),
      ) %>%
      group_by(source, iteration) %>%
      filter(
        source != "bootstrapped" |
        any(largest_loading & index_loading >= first_quartile)
      ) %>%
      group_by(source, variable) %>%
      mutate(
        low_limit = quantile(index_loading, (1 - pca_test$loadings_confint)/2),
        high_limit = quantile(index_loading, 1 - (1 - pca_test$loadings_confint)/2)
      ) %>%
      ungroup() %>%
      mutate(
        distribution = if_else(
          source == "bootstrapped",
          "Confidence",
          "Null"
        )
      ) %>%
      select(-index_loading, -loading) %>%
      left_join(
        pca_test$loadings %>% select(PC, variable, index_loading, loading),
        by = c("PC", "variable")
      )

    # Needs to be added as a caption.
    kept_iterations <- plot_data %>%
      filter(
        distribution == "Confidence"
      ) %>%
      pull(iteration) %>%
      base::unique() %>%
      base::length()

    subtitle = glue(
      "Filtered Bootstrap Confidence Intevals ({kept_iterations} Iterations) ",
      "and Permutation-Based Null Distribution"
    )

  } else {

    plot_data <- pca_test$loadings %>%
      # Filter so we only have data from desired PC.
      filter(
        as.numeric(str_sub(PC, start = 3L)) == pc_no
      ) %>%
      # Reshape so that both permutation and bootstrapped limits are on same
      # variables.
      pivot_longer(
        cols = contains('low'),
        names_to = "distribution",
        values_to = 'low_limit',
        names_pattern = "_(.*)"
      ) %>%
      pivot_longer(
        cols = contains('high'),
        names_to = "distribution_2",
        values_to = 'high_limit',
        names_pattern = "_(.*)"
      ) %>%
      filter(
        distribution == distribution_2
      ) %>%
      select(-distribution_2) %>%
      mutate(
        distribution = if_else(
          str_detect(distribution, 'null'),
          "Null",
          "Confidence"
        )
      )

    subtitle = glue(
      "Bootstraped Confidence Intevals and Permutation-Based Null Distribution"
    )

  }

  plot_data <- plot_data %>%
    mutate(
      # Reorder 'variable'  column so variables plotted in ascending order by
      # loading.
      variable = fct_reorder(variable, index_loading),
      loading_sign = if_else(.data$loading < 0, "-", "+")
    )

  if (violin) {

    violin_data <- pca_test$raw_data %>%
      filter(
        source == "bootstrapped",
        as.numeric(str_sub(PC, start = 3L)) == pc_no
      ) %>%
      mutate(
        distribution = "Confidence"
      ) %>%
      select(
        distribution, variable, index_loading, loading, iteration
      ) %>%
      # Reorder 'variable'  column so variables plotted in ascending order by
      # median bootstrapped loading.
      group_by(variable) %>%
      mutate(
        median_index = median(index_loading)
      ) %>%
      ungroup() %>%
      mutate(
        variable = fct_reorder(variable, median_index)
      )

    if (filter_boots) {
      violin_data <- violin_data %>%
        group_by(variable) %>%
        mutate(
          first_quartile = quantile(index_loading, 0.25)
        ) %>%
        ungroup() %>%
        mutate(
          largest_loading = median_index == max(median_index),
        ) %>%
        group_by(iteration) %>%
        filter(
          any(largest_loading & index_loading >= first_quartile)
        )

      kept_iterations <- base::length(base::unique(violin_data$iteration))

    }

    violin_element <- geom_violin(
        data = violin_data
      )

  } else {

    violin_element <- NULL

  }

  out_plot <- plot_data %>%
    ggplot(
      aes(
        x = variable,
        y = index_loading,
        colour = distribution
      )
    ) +
    violin_element +
    geom_errorbar(
      aes(
        ymin = low_limit,
        ymax = high_limit
      )
    ) +
    # geom_point(colour = "red") +
    geom_text(aes(label = loading_sign), size = 8, colour = "black") +
    scale_x_discrete(guide = guide_axis(angle = 90)) +
    labs(
      title = glue("Index Loadings for PC{pc_no}"),
      subtitle = subtitle,
      colour = "Distribution",
      y = "Index Loading",
      x = "Variable"
    )

  out_plot

}
